---
title: "Predictive Maintenance for Turbofan Engines"
subtitle: "Statistical Programming with R"
author: "Aymen Mabrouk"
institute: "Ecole Polytechnique Sousse"
date: "2025-11-21"
format:
  revealjs:
    theme: simple
    transition: slide
    background-transition: fade
    slide-number: true
    show-slide-number: all
    preview-links: auto
    logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/R_logo.svg/724px-R_logo.svg.png"
    css: styles.css
    footer: "Supervised by Pr. Abdallah Khemais"
    code-fold: true
    code-tools: true
    height: 900
    width: 1600
execute:
  echo: true
  warning: false
  message: false
  cache: true
---

# Executive Summary {background-color="#2C3E50"}

## The Mission üéØ

::: {.incremental}
-   **The Problem:** Aircraft engines are expensive. Replacing them too early wastes money; replacing them too late risks safety.
-   **The Goal:** Predict the **Remaining Useful Life (RUL)** of jet engines using high-frequency sensor data.
-   **The Dataset:** NASA C-MAPSS (Commercial Modular Aero-Propulsion System Simulation).
-   **The Result:** Achieved an **RMSE of 17.53**, successfully predicting failure onset 50 cycles in advance.
:::

# Methodology & Architecture üõ†Ô∏è {background-color="#2C3E50"}

## The Pipeline

We implemented a dual-track statistical and machine learning approach:

::: {.panel-tabset}

### 1. Ingestion
- **Data Source:** NASA FD001 (Run-to-Failure).
- **Cleaning:** Removed ghost columns caused by trailing spaces.
- **Target Gen:** Calculated `RUL = Max Cycle - Current Cycle`.

### 2. Statistics
- **Method:** Survival Analysis.
- **Model:** Cox Proportional Hazards.
- **Outcome:** Identified "Killer Sensors" via Hazard Ratios.

### 3. Feature Eng
- **Rolling Windows:** Calculated `Mean` and `SD` (Volatility) over 5 cycles.
- **PCA:** Dimensionality reduction for visualization.

### 4. Machine Learning
- **Model:** Random Forest Regressor.
- **Strategy:** "Clipped RUL" (125 cycles) to reduce noise.
- **Validation:** Tested on unseen fleet (`test_FD001`).
:::

# Phase 1: Data Forensics üîç {background-color="#ffffff"}

## Setup & Ingestion

Loading the Tidyverse ecosystem and preparing the raw data.

```{r}
#| echo: true
#| output-location: fragment
library(tidyverse)
library(survival)
library(survminer)
library(randomForest)
library(zoo)
library(plotly)

# Load Training Data (Adjust path if necessary)
# Assuming data is in current directory or 'data/' folder
data_path <- if (file.exists("data/train_FD001.txt")) "data/train_FD001.txt" else "train_FD001.txt"
raw_data <- read.table(data_path, header = FALSE)
raw_data <- raw_data[, 1:26] # Ghost column fix

col_names <- c(
    "unit_id", "cycle", "setting_1", "setting_2", "setting_3",
    paste0("s", 1:21)
)
colnames(raw_data) <- col_names

# Engineering RUL
data_clean <- raw_data %>%
    group_by(unit_id) %>%
    mutate(
        max_cycle = max(cycle),
        RUL = max_cycle - cycle,
        failed = ifelse(RUL == 0, 1, 0)
    ) %>%
    ungroup()

# Selecting active sensors
data_final <- data_clean %>%
    select(-s1, -s5, -s10, -s16, -s18, -s19, -setting_1, -setting_2, -setting_3)

head(data_final %>% select(unit_id, cycle, RUL, s11, s12), 3)
```

# Phase 2: Survival Analysis üìâ {background-color="#ffffff"}

## The "Death Signature"

Before modeling, we visualize how sensors behave as the engine approaches failure (RUL = 0).

```{r}
#| label: death-sig
#| fig-width: 10
#| fig-height: 5

p <- ggplot(data_final %>% filter(unit_id <= 4), aes(x = RUL, y = s11, color = factor(unit_id))) +
    geom_line(size = 1) +
    scale_x_reverse() +
    labs(
        title = "Sensor 11 (Pressure) Degradation",
        subtitle = "Pressure rises significantly as engine approaches failure",
        x = "Remaining Useful Life (RUL)", y = "Static Pressure (s11)", color = "Engine"
    ) +
    theme_minimal()
p
```

## Cox Proportional Hazards

We use statistics to quantify **Risk**. Which sensor is the killer?

```{r}
#| echo: true
cox_model <- coxph(Surv(cycle, failed) ~ s11 + s12 + s4, data = data_final)

# Extracting Hazard Ratios for plotting
cox_results <- summary(cox_model)$conf.int %>%
    as.data.frame() %>%
    rownames_to_column(var = "Sensor") %>%
    rename(HR = `exp(coef)`, Lower = `lower .95`, Upper = `upper .95`)

ggplot(cox_results, aes(x = HR, y = Sensor)) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
    geom_point(size = 5, color = "darkblue") +
    geom_errorbarh(aes(xmin = Lower, xmax = Upper), height = 0.2) +
    labs(
        title = "Hazard Ratios (Risk Factors)",
        subtitle = "Sensor 11 > 1.0 implies massive risk increase",
        x = "Hazard Ratio"
    ) +
    theme_minimal(base_size = 18)
```

::: {.callout-important}
**Insight:** Sensor 11 (Static Pressure) has a Hazard Ratio > 200. It is the primary leading indicator of failure.
:::

# Phase 3: Advanced Machine Learning ü§ñ {background-color="#2C3E50"}

## Feature Engineering (Rolling Stats)

Engines don't just fail; they vibrate. We calculate rolling **Mean** (Trend) and **Standard Deviation** (Volatility).

```{r}
#| echo: true
sensors <- c("s2", "s3", "s4", "s6", "s7", "s8", "s9", "s11", "s12", "s13", "s14", "s15", "s17", "s20", "s21")

data_ml <- data_clean %>%
    mutate(RUL_clipped = ifelse(RUL > 125, 125, RUL)) %>%
    group_by(unit_id) %>%
    arrange(unit_id, cycle) %>%
    mutate(across(all_of(sensors),
        list(
            mean = ~ rollmean(., k = 5, fill = NA, align = "right"),
            sd = ~ rollapply(., width = 5, FUN = sd, fill = NA, align = "right")
        ),
        .names = "{.col}_{.fn}"
    )) %>%
    ungroup() %>%
    filter(complete.cases(.))
```

## The Oracle: Random Forest

Training the model to predict the exact number of cycles remaining.

```{r}
#| echo: true
# Training a lightweight version for presentation rendering
rf_model <- randomForest(RUL_clipped ~ .,
    data = data_ml %>% select(-unit_id, -cycle, -RUL, -failed, -max_cycle),
    ntree = 30,
    importance = TRUE
)

imp_df <- as.data.frame(importance(rf_model)) %>%
    rownames_to_column("Feature") %>%
    arrange(desc(`%IncMSE`)) %>%
    head(10)

ggplot(imp_df, aes(x = reorder(Feature, `%IncMSE`), y = `%IncMSE`)) +
    geom_bar(stat = "identity", fill = "firebrick") +
    coord_flip() +
    labs(title = "Top Predictors of Failure", x = "Sensor Feature", y = "Importance") +
    theme_minimal(base_size = 18)
```

# Phase 4: Validation & Results üèÜ {background-color="#ffffff"}

## Test Data Evaluation

We validate on the unseen `test_FD001` fleet against the Ground Truth (`RUL_FD001`).

```{r}
#| echo: false
# Load Test Data
test_path <- if (file.exists("data/test_FD001.txt")) "data/test_FD001.txt" else "test_FD001.txt"
rul_path <- if (file.exists("data/RUL_FD001.txt")) "data/RUL_FD001.txt" else "RUL_FD001.txt"

raw_test <- read.table(test_path, header = FALSE)[, 1:26]
colnames(raw_test) <- col_names
true_rul <- read.table(rul_path, header = FALSE)
colnames(true_rul) <- c("True_RUL")

# Engineer Test Data
test_engineered <- raw_test %>%
    group_by(unit_id) %>%
    arrange(unit_id, cycle) %>%
    mutate(across(all_of(sensors),
        list(
            mean = ~ rollmean(., k = 5, fill = NA, align = "right"),
            sd = ~ rollapply(., width = 5, FUN = sd, fill = NA, align = "right")
        ),
        .names = "{.col}_{.fn}"
    )) %>%
    filter(cycle == max(cycle)) %>%
    ungroup()

test_engineered$True_RUL <- true_rul$True_RUL[1:nrow(test_engineered)]
test_engineered$True_RUL_Clipped <- ifelse(test_engineered$True_RUL > 125, 125, test_engineered$True_RUL)

# Predict
test_engineered$Predicted_RUL <- predict(rf_model, newdata = test_engineered)
rmse <- sqrt(mean((test_engineered$True_RUL_Clipped - test_engineered$Predicted_RUL)^2))
```

::: {.r-stack}
::: {.fragment .fade-in-then-out}
**Calculating RMSE...**
:::
::: {.fragment .fade-in}
### Final Score: RMSE = `r round(rmse, 2)`
:::
:::

## Prediction vs Reality

The "Perfect Prediction" line is dashed red. Blue dots are our AI.

```{r}
#| fig-width: 10
#| fig-height: 6
ggplot(test_engineered, aes(x = True_RUL_Clipped, y = Predicted_RUL)) +
    geom_point(color = "blue", alpha = 0.6, size = 3) +
    geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed", size = 1.2) +
    labs(
        title = "Accuracy Check: Predicted vs Actual RUL",
        subtitle = paste("RMSE:", round(rmse, 2), "| Closer to red line = Better"),
        x = "Actual Remaining Life", y = "Predicted Remaining Life"
    ) +
    theme_minimal(base_size = 16)
```

# Conclusion {background-color="#2C3E50"}

## Summary of Achievements

1.  **Statistical Rigor:** Used Cox Models to validate sensor physics.
2.  **Feature Mastery:** Engineered rolling volatility metrics to detect instability.
3.  **High Accuracy:** Achieved **RMSE 17.53**, surpassing standard benchmarks (<20).
4.  **Business Value:** This model enables "Just-in-Time" maintenance, reducing costs and preventing catastrophic failure.

::: {.fragment}
### Thank You
**Aymen Mabrouk**
<br>
*Ecole Polytechnique Sousse*
:::
